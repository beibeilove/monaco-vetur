define([], function() { return { contents: "type ScopedSlot = (props: any) => VNodeChildrenArrayContents | string;\n\ntype VNodeChildren = VNodeChildrenArrayContents | [ScopedSlot] | string;\ninterface VNodeChildrenArrayContents {\n	[x: number]: VNode | string | VNodeChildren;\n}\n\ninterface VNode {\n	tag?: string;\n	data?: VNodeData;\n	children?: VNode[];\n	text?: string;\n	elm?: Node;\n	ns?: string;\n	context?: Vue;\n	key?: string | number;\n	componentOptions?: VNodeComponentOptions;\n	componentInstance?: Vue;\n	parent?: VNode;\n	raw?: boolean;\n	isStatic?: boolean;\n	isRootInsert: boolean;\n	isComment: boolean;\n}\n\ninterface VNodeComponentOptions {\n	Ctor: typeof Vue;\n	propsData?: Object;\n	listeners?: Object;\n	children?: VNodeChildren;\n	tag?: string;\n}\n\ninterface VNodeData {\n	key?: string | number;\n	slot?: string;\n	scopedSlots?: { [key: string]: ScopedSlot };\n	ref?: string;\n	tag?: string;\n	staticClass?: string;\n	class?: any;\n	staticStyle?: { [key: string]: any };\n	style?: Object[] | Object;\n	props?: { [key: string]: any };\n	attrs?: { [key: string]: any };\n	domProps?: { [key: string]: any };\n	hook?: { [key: string]: Function };\n	on?: { [key: string]: Function | Function[] };\n	nativeOn?: { [key: string]: Function | Function[] };\n	transition?: Object;\n	show?: boolean;\n	inlineTemplate?: {\n		render: Function;\n		staticRenderFns: Function[];\n	};\n	directives?: VNodeDirective[];\n	keepAlive?: boolean;\n}\n\ninterface VNodeDirective {\n	readonly name: string;\n	readonly value: any;\n	readonly oldValue: any;\n	readonly expression: any;\n	readonly arg: string;\n	readonly modifiers: { [key: string]: boolean };\n}\n\n\ntype Constructor = {\n	new(...args: any[]): any;\n}\n\ntype Component = typeof Vue | ComponentOptions<Vue> | FunctionalComponentOptions;\ntype AsyncComponent = (\n	resolve: (component: Component) => void,\n	reject: (reason?: any) => void\n) => Promise<Component> | Component | void;\n\ninterface ComponentOptions<V extends Vue> {\n	data?: Object | ((this: V) => Object);\n	props?: string[] | { [key: string]: PropOptions | Constructor | Constructor[] };\n	propsData?: Object;\n	computed?: { [key: string]: ((this: V) => any) | ComputedOptions<V> };\n	methods?: { [key: string]: (this: V, ...args: any[]) => any };\n	watch?: { [key: string]: ({ handler: WatchHandler<V, any> } & WatchOptions) | WatchHandler<V, any> | string };\n\n	el?: Element | String;\n	template?: string;\n	render?(this: V, createElement: CreateElement): VNode;\n	renderError?: (h: () => VNode, err: Error) => VNode;\n	staticRenderFns?: ((createElement: CreateElement) => VNode)[];\n\n	beforeCreate?(this: V): void;\n	created?(this: V): void;\n	beforeDestroy?(this: V): void;\n	destroyed?(this: V): void;\n	beforeMount?(this: V): void;\n	mounted?(this: V): void;\n	beforeUpdate?(this: V): void;\n	updated?(this: V): void;\n	activated?(this: V): void;\n	deactivated?(this: V): void;\n\n	directives?: { [key: string]: DirectiveOptions | DirectiveFunction };\n	components?: { [key: string]: Component | AsyncComponent };\n	transitions?: { [key: string]: Object };\n	filters?: { [key: string]: Function };\n\n	provide?: Object | (() => Object);\n	inject?: { [key: string]: string | symbol } | Array<string>;\n\n	model?: {\n		prop?: string;\n		event?: string;\n	};\n\n	parent?: Vue;\n	mixins?: (ComponentOptions<Vue> | typeof Vue)[];\n	name?: string;\n	extends?: ComponentOptions<Vue> | typeof Vue;\n	delimiters?: [string, string];\n	comments?: boolean;\n	inheritAttrs?: boolean;\n}\n\ninterface FunctionalComponentOptions {\n	name?: string;\n	props?: string[] | { [key: string]: PropOptions | Constructor | Constructor[] };\n	functional: boolean;\n	render(this: never, createElement: CreateElement, context: RenderContext): VNode | void;\n}\n\ninterface RenderContext {\n	props: any;\n	children: VNode[];\n	slots(): any;\n	data: VNodeData;\n	parent: Vue;\n	injections: any\n}\n\ninterface PropOptions {\n	type?: Constructor | Constructor[] | null;\n	required?: boolean;\n	default?: any;\n	validator?(value: any): boolean;\n}\n\ninterface ComputedOptions<V> {\n	get?(this: V): any;\n	set?(this: V, value: any): void;\n	cache?: boolean;\n}\n\ntype WatchHandler<V, T> = (this: V, val: T, oldVal: T) => void;\n\ninterface WatchOptions {\n	deep?: boolean;\n	immediate?: boolean;\n}\n\ntype DirectiveFunction = (\n	el: HTMLElement,\n	binding: VNodeDirective,\n	vnode: VNode,\n	oldVnode: VNode\n) => void;\n\ninterface DirectiveOptions {\n	bind?: DirectiveFunction;\n	inserted?: DirectiveFunction;\n	update?: DirectiveFunction;\n	componentUpdated?: DirectiveFunction;\n	unbind?: DirectiveFunction;\n}\n\ntype PluginFunction<T> = (Vue, options?: T) => void;\n\ninterface PluginObject<T> {\n	install: PluginFunction<T>;\n	[key: string]: any;\n}\n\ntype CreateElement = {\n	// empty node\n	(): VNode;\n\n	// element or component name\n	(tag: string, children: VNodeChildren): VNode;\n	(tag: string, data?: VNodeData, children?: VNodeChildren): VNode;\n\n	// component constructor or options\n	(tag: Component, children: VNodeChildren): VNode;\n	(tag: Component, data?: VNodeData, children?: VNodeChildren): VNode;\n\n	// async component\n	(tag: AsyncComponent, children: VNodeChildren): VNode;\n	(tag: AsyncComponent, data?: VNodeData, children?: VNodeChildren): VNode;\n}\n\ndeclare class Vue {\n\n	constructor(options?: ComponentOptions<Vue>);\n\n	$data: Object;\n	readonly $el: HTMLElement;\n	readonly $options: ComponentOptions<this>;\n	readonly $parent: Vue;\n	readonly $root: Vue;\n	readonly $children: Vue[];\n	readonly $refs: { [key: string]: Vue | Element | Vue[] | Element[] };\n	readonly $slots: { [key: string]: VNode[] };\n	readonly $scopedSlots: { [key: string]: ScopedSlot };\n	readonly $isServer: boolean;\n	readonly $ssrContext: any;\n	readonly $props: any;\n	readonly $vnode: VNode;\n	readonly $attrs: { [key: string]: string } | void;\n	readonly $listeners: { [key: string]: Function | Array<Function> } | void;\n\n	$mount(elementOrSelector?: Element | String, hydrating?: boolean): this;\n	$forceUpdate(): void;\n	$destroy(): void;\n	$set: typeof Vue.set;\n	$delete: typeof Vue.delete;\n	$watch(\n		expOrFn: string,\n		callback: WatchHandler<this, any>,\n		options?: WatchOptions\n	): (() => void);\n	$watch<T>(\n		expOrFn: (this: this) => T,\n		callback: WatchHandler<this, T>,\n		options?: WatchOptions\n	): (() => void);\n	$on(event: string | string[], callback: Function): this;\n	$once(event: string, callback: Function): this;\n	$off(event?: string | string[], callback?: Function): this;\n	$emit(event: string, ...args: any[]): this;\n	$nextTick(callback: (this: this) => void): void;\n	$nextTick(): Promise<void>;\n	$createElement: CreateElement;\n\n	static config: {\n		silent: boolean;\n		optionMergeStrategies: any;\n		devtools: boolean;\n		productionTip: boolean;\n		performance: boolean;\n		errorHandler(err: Error, vm: Vue, info: string): void;\n		warnHandler(msg: string, vm: Vue, trace: string): void;\n		ignoredElements: string[];\n		keyCodes: { [key: string]: number };\n	}\n\n	static extend(options: ComponentOptions<Vue> | FunctionalComponentOptions): typeof Vue;\n	static nextTick(callback: () => void, context?: any[]): void;\n	static nextTick(): Promise<void>\n	static set<T>(object: Object, key: string, value: T): T;\n	static set<T>(array: T[], key: number, value: T): T;\n	static delete(object: Object, key: string): void;\n	static delete<T>(array: T[], key: number): void;\n\n	static directive(\n		id: string,\n		definition?: DirectiveOptions | DirectiveFunction\n	): DirectiveOptions;\n	static filter(id: string, definition?: Function): Function;\n	static component(id: string, definition?: Component | AsyncComponent): typeof Vue;\n\n	static use<T>(plugin: PluginObject<T> | PluginFunction<T>, options?: T): void;\n	static mixin(mixin: typeof Vue | ComponentOptions<Vue>): void;\n	static compile(template: string): {\n		render(createElement: typeof Vue.prototype.$createElement): VNode;\n		staticRenderFns: (() => VNode)[];\n	};\n}"}; });